{"pageProps":{"note":{"id":"vhn93xdheb909udqychwrcl","title":"Mapping_lineages","desc":"This note describes the algorithm of mapping lineage","updated":1703594678282,"created":1702286483115,"custom":{},"fname":"Work_documented.Mapping_lineages","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Literature"},"contentHash":"1271044163cccb97864a5b694781c570","links":[{"type":"wiki","from":{"fname":"Work_documented.Mapping_lineages","id":"vhn93xdheb909udqychwrcl","vaultName":"Literature"},"value":"Work_documented.possible_questions","alias":"question on the treshold","position":{"start":{"line":154,"column":1,"offset":5694},"end":{"line":154,"column":153,"offset":5846},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"Work_documented.possible_questions","anchorHeader":"3-the-jaccard-index-treshold-chosen-to-decide-a-parent-or-a-neighbour-is-50-is-this-okay"}}],"anchors":{},"children":[],"parent":"r423m96u71ix4pb458fk8u2","data":{}},"body":"<h1 id=\"mapping_lineages\">Mapping_lineages<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#mapping_lineages\"></a></h1>\n<pre class=\"language-{algorithm}\"><code class=\"language-{Algorithm}\">Function mapping_lineages (lineage_cmut,alias_df)\n\n    Function chunk_lineage(lineage_cmut,alias_df)\n        \n        1.Chunks lineages and sublineages by the first character of Pangolin string. \n        One element of the input data frame is considered at an instance and all the \n        members of the clade to which it belongs are chunked and passed to the downstream \n        processing.\n\n        2. If there are no lineages having the same first \n        character but there are entries in the input df, the lineage is \n        mapped to it's own and is stored in alias_df.\n\n        3. else If the there are no more entries in the \n        lineage_cmut then the lineage is mapped to itself and  return is called.\n\n        4. else the chunk stored in temp_df is passed to\n        long_sublineage\n\n    End\n\n    Function long_sublineage(temp_df,lineage_cmut,\n    alias_df,alias_df_temp)\n\n        1. Finds the sublineage with longest character string\n        and stores it in longlineage_df\n\n        2. If multiple lineages have long character string\n        both the lineages are stored in longlineage_df\n\n        3. If linegaes length is just one then it is the\n        parental lineage and it is mapped to it's own and is\n        removed from temp_df amd is stored in alias_df\n\n    END\n\n    Function match_merge(longlineage_df,temp_df\n    lineage_cmut,alias_df,alias_df_temp)\n\n    1. Iterates through the longlineage_df, forms pattern\n    from the first element taken and tries to find\n    neighbours in longlineage_df based on jaccard value\n    using function find_jaccard\n\n        1. If neighbours are found their mutations are\n        combined (union).\n\n        2. Checks if these neighbors are paretnal lineage to\n        some other lineage in the alias_temp_df\n\n        3. Checking if there is a parental lineage to the\n        neighbours in the temp_df\n\n        4. If parental lineage is found and if the length of the parental \n        lineage string is more than one, the mutations of the\n        neighbours and the parernal lineages are again\n        combined (union) and stored in the place of \n        mutations of the parental lineage in temp_df. Neighbours are \n        mapped to their found parent and are stored in alias_df_temp, \n        since there is potential for surther mapping. This parental \n        lineage also becomes the parental lineage for the \n        sublineages that had these neighbours as parental \n        lineage in alias_df_temp.These neighbors are removed from \n        longlineage_df and the loop is iterated for the next round.\n        \n        5. Else if the length of the parental lineage is \n        equal to 1 then everything in the previous point \n        that was written in the alias_df_temp is written to\n        alias_df. Mutations are not meddled with, since it is \n        the ultimate paretnal lineage and there is no go further.\n\n        6. If no parental lineage was found then the the\n        Neighbours are mapped to the pattern which is the\n        name of the neigbors without the last character. This\n        pattern concatinated with x becomes the parental \n        lineage of the neighbors. This also becomes the \n        parental lineage for those sublineages for which the \n        nighbors were parental lineage.\n\n    2. If there are no neighbors found\n\n        1. Code directly starts finding the parental \n        lineage for the element being considered.\n\n        2. If paretnal lineage is found and the length of \n        the lineage is more than 1, the element in hand \n        is mapped to the found paretnal lineage and jaccard \n        value is stored in the alias_df_temp.  Mutations of \n        the element and the found parental lineage is combined and \n        stored in the place of the parental mutations in temp_df\n\n        3. Sublineages for which the lineage in hand is the parental\n        lineage in alias_df_temp gets mapped to the newly found parental lineage.\n\n        4. If the length of the parental lineage being \n        found is equal to one then point 2,3 is repeated \n        but difference would be that instaed of \n        alias_temp_df, alias_df is used and mutations are not meddeled with.\n\n    3. If no parerntal and neighbors were found\n\n        1. The lineage being considered is mapped to \n        itself.\n\n        2. For sublineages in the alias_df_temp that has \n        the lineage being considered as parental lineage is \n        remains the same. It is just transfered to \n        alias_df with no changes.\n\n    \n    Once the longlineage_df has been fully processed if \n    there are entries in temp_df long_sublineage is called else chunk lineage is called.\n    \n\n\n\n    END\n\nEnd\n</code></pre>\n<pre class=\"language-{algorithm}\"><code class=\"language-{Algorithm}\">Function find_jaccard(pat,search_df,pat_mutations=0)\n\n    search_lineage_loc&#x3C;-grep(pat,search_df$lineage)\n\n    1. If pat_mutations==0 means the function is finding the\n    neighbours. Else the function is overloaded\n    to find the parental lineage.\n\n    2. If pat_mutations==0 the length(search_lineage_loc) should be\n    more than 1 - neighbours other than the lineage in hand.\n\n    3. If no neighbours were found then function returns \n    neighbours=\"0\", jaccard_value=-1,neighbour_loc=0\n\n    4. Other than point 2 the overloaded function does the\n    same functionality for both the overloaded purposes\n    and returns jaccard value, neighbours, neighbour_loc \nEnd\n</code></pre>\n<pre class=\"language-{find\"><code class=\"language-{Find\">Function Find_parental(pat,parental_df)\n\n    1. Recursively searches with the pattern \n    until it finds the parental lineage satisfying \n    the conditions \n    2. The pattern is shortened every iteration.\nEnd\n</code></pre>\n<p><img src=\"/SARS-Cov2/assets/Pics/mapping_lineages.png\" alt=\"Flowchart to explain\">\n<a href=\"/SARS-Cov2/notes/xhw6w5ghbjhkzbo7huxzhwg#3-the-jaccard-index-treshold-chosen-to-decide-a-parent-or-a-neighbour-is-50-is-this-okay\">question on the treshold</a></p>","noteIndex":{"id":"paa0s59lp320n6q8rghycjw","title":"Work on SARS Cov2","desc":"","updated":1700240746536,"created":1700233379150,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Literature"},"contentHash":"6124b7f80065618c049c13a49f0dbed1","links":[],"anchors":{},"children":["1hnn8maoednnxdw5feqd4kq","nve3ld8zkeg6b2hgygrh1rp","v4t96j5kch5mq12272qsyih","r423m96u71ix4pb458fk8u2"],"parent":null,"data":{},"body":"\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"Literature"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://vishnushiri02.github.io","assetsPrefix":"/SARS-Cov2","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}